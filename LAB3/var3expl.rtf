{\rtf1\ansi\ansicpg1252\cocoartf2821
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 This MIPS assembly code implements a program that sorts an array of integers using the **Insertion Sort** algorithm. The program is divided into several functions, each with a specific role. Below is a detailed explanation of how the code works:\
\
---\
\
### **Data Segment**\
The `.data` section defines strings used for user prompts and output messages:\
- `promptSize`: Asks the user to input the size of the array.\
- `promptElements`: Asks the user to input the array elements.\
- `outputMsg`: Displays the sorted array.\
- `newline`: Used for formatting output.\
\
---\
\
### **Text Segment**\
The `.text` section contains the executable code, including the main function and helper functions.\
\
---\
\
### **Functions**\
\
#### 1. **`insert` Function**\
This function inserts an element into a specific position in the array and shifts the remaining elements to the right.\
\
- **Arguments**:\
  - `$a0`: Base address of the array.\
  - `$a1`: Length of the array.\
  - `$a2`: Element to insert.\
  - `$a3`: Position to insert the element.\
\
- **Steps**:\
  1. Save registers (`$ra`, `$s0`, `$s1`, `$s2`) to the stack.\
  2. Initialize `$s0` as `j = length - 1` (index for shifting elements).\
  3. Use a loop (`shift_loop`) to shift elements to the right until the insertion position is reached.\
  4. Insert the element at the specified position.\
  5. Restore registers and return.\
\
---\
\
#### 2. **`binarySearch` Function**\
This function performs a binary search to find the correct position to insert an element in a sorted array.\
\
- **Arguments**:\
  - `$a0`: Base address of the array.\
  - `$a1`: Length of the array.\
  - `$a2`: Element to search for.\
\
- **Returns**:\
  - `$v0`: Position where the element should be inserted.\
\
- **Steps**:\
  1. Save registers (`$ra`, `$s0`, `$s1`, `$s2`, `$s3`) to the stack.\
  2. Initialize `low = -1` and `high = length`.\
  3. Use a loop (`search_loop`) to perform binary search:\
     - Calculate `mid = (low + high) / 2`.\
     - Compare `a[mid]` with the element to insert.\
     - Adjust `low` or `high` based on the comparison.\
  4. Return `high` as the insertion position.\
  5. Restore registers and return.\
\
---\
\
#### 3. **`insertionSort` Function**\
This function sorts the array using the Insertion Sort algorithm.\
\
- **Arguments**:\
  - `$a0`: Base address of the array.\
  - `$a1`: Length of the array.\
\
- **Steps**:\
  1. Save registers (`$ra`, `$s0`, `$s1`, `$s2`, `$s3`, `$s4`, `$s5`) to the stack.\
  2. Allocate memory for a temporary array `b` using the `sbrk` syscall.\
  3. Use a loop (`sort_loop`) to iterate through the original array:\
     - For each element, call `binarySearch` to find its position in the sorted array `b`.\
     - Call `insert` to place the element in the correct position in `b`.\
  4. Copy the sorted array `b` back to the original array `a`.\
  5. Restore registers and return.\
\
---\
\
### **Main Function**\
The `main` function orchestrates the program flow:\
1. **Prompt for Array Size**:\
   - Print the `promptSize` message.\
   - Read the array size from the user and store it in `$s0`.\
\
2. **Allocate Memory for the Array**:\
   - Calculate the required memory size (`length * 4` bytes).\
   - Use the `sbrk` syscall to allocate memory and store the base address in `$s1`.\
\
3. **Read Array Elements**:\
   - Print the `promptElements` message.\
   - Use a loop (`read_loop`) to read each element from the user and store it in the array.\
\
4. **Sort the Array**:\
   - Call the `insertionSort` function to sort the array.\
\
5. **Print the Sorted Array**:\
   - Print the `outputMsg` message.\
   - Use a loop (`print_loop`) to print each element of the sorted array.\
\
6. **Exit**:\
   - Restore the return address and exit the program using the `exit` syscall.\
\
---\
\
### **Key Points**\
- **Dynamic Memory Allocation**: The program uses the `sbrk` syscall to allocate memory for the array.\
- **Binary Search for Insertion Sort**: Instead of the traditional Insertion Sort, this implementation uses binary search to find the correct position for each element, improving efficiency.\
- **Temporary Array**: A temporary array `b` is used to build the sorted array before copying it back to the original array `a`.\
\
---\
\
### **Example Execution**\
1. User inputs:\
   - Array size: `5`\
   - Elements: `[3, 1, 4, 2, 5]`\
\
2. Program output:\
   ```\
   The sorted array is:\
   1\
   2\
   3\
   4\
   5\
   ```\
\
---\
\
### **Summary**\
This MIPS program demonstrates:\
- Dynamic memory allocation.\
- Binary search for efficient insertion.\
- Insertion Sort using a temporary array.\
- User input and output handling.\
\
By understanding each function and its role, you can see how the program efficiently sorts an array using a combination of binary search and insertion sort.}